package actions

import (
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/nemesisesq/groomly/models"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Opportunity)
// DB Table: Plural (opportunities)
// Resource: Plural (Opportunities)
// Path: Plural (/opportunities)
// View Template Folder: Plural (/templates/opportunities/)

// OpportunitiesResource is the resource for the Opportunity model
type OpportunitiesResource struct {
	buffalo.Resource
}

// List gets all Opportunities. This function is mapped to the path
// GET /opportunities
func (v OpportunitiesResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	opportunities := &models.Opportunities{}

	// Paginate results. Params "page" and "per_page" control pagination.
	// Default values are "page=1" and "per_page=20".
	q := tx.PaginateFromParams(c.Params())

	// Retrieve all Opportunities from the DB
	if err := q.Eager().All(opportunities); err != nil {
		return errors.WithStack(err)
	}

	// Add the paginator to the context so it can be used in the template.
	c.Set("pagination", q.Paginator)

	return c.Render(200, r.Auto(c, opportunities))
}

// Show gets the data for one Opportunity. This function is mapped to
// the path GET /opportunities/{opportunity_id}
func (v OpportunitiesResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Opportunity
	opportunity := &models.Opportunity{}

	// To find the Opportunity the parameter opportunity_id is used.
	if err := tx.Eager().Find(opportunity, c.Param("opportunity_id")); err != nil {
		return c.Error(404, err)
	}

	for i, mv := range opportunity.MetricValues {
		m := &models.Metric{}
		v := &models.Value{}
		tx.Eager().Find(m, mv.MetricID)
		tx.Eager().Find(v, mv.ValueID)
		mv.Metric = *m
		mv.Value = *v
		opportunity.MetricValues[i] = mv

	}

	return c.Render(200, r.Auto(c, opportunity))
}

// New renders the form for creating a new Opportunity.
// This function is mapped to the path GET /opportunities/new
func (v OpportunitiesResource) New(c buffalo.Context) error {
	return c.Render(200, r.Auto(c, &models.Opportunity{}))
}

// Create adds a Opportunity to the DB. This function is mapped to the
// path POST /opportunities
func (v OpportunitiesResource) Create(c buffalo.Context) error {
	// Allocate an empty Opportunity
	opportunity := &models.Opportunity{}

	// Bind opportunity to the html form elements
	if err := c.Bind(opportunity); err != nil {
		return errors.WithStack(err)
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(opportunity)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.Auto(c, opportunity))
	}
	// create metrics

	for _, v := range opportunity.MetricValues {

		mv := &models.MetricValue{}
		mv.OpportunityID = opportunity.ID
		mv.MetricID = v.Metric.ID
		mv.ValueID = v.Value.ID

		// link Metrics with The Opportunity

		verrs, err = tx.ValidateAndCreate(mv)

		if err != nil {
			return errors.WithStack(err)
		}

		if verrs.HasAny() {
			// Make the errors available inside the html template
			c.Set("errors", verrs)

			// Render again the new.html template that the user can
			// correct the input.
			return c.Render(422, r.Auto(c, opportunity))
		}
	}

	// If there are no errors set a success message
	c.Flash().Add("success", "Opportunity was created successfully")

	// and redirect to the opportunities index page
	return c.Render(201, r.Auto(c, opportunity))
}

// Edit renders a edit form for a Opportunity. This function is
// mapped to the path GET /opportunities/{opportunity_id}/edit
func (v OpportunitiesResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Opportunity
	opportunity := &models.Opportunity{}

	if err := tx.Find(opportunity, c.Param("opportunity_id")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.Auto(c, opportunity))
}

// Update changes a Opportunity in the DB. This function is mapped to
// the path PUT /opportunities/{opportunity_id}
func (v OpportunitiesResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Opportunity
	opportunity := &models.Opportunity{}

	if err := tx.Find(opportunity, c.Param("opportunity_id")); err != nil {
		return c.Error(404, err)
	}

	// Bind Opportunity to the html form elements
	if err := c.Bind(opportunity); err != nil {
		return errors.WithStack(err)
	}

	verrs, err := tx.ValidateAndUpdate(opportunity)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the edit.html template that the user can
		// correct the input.
		return c.Render(422, r.Auto(c, opportunity))
	}

	// If there are no errors set a success message
	c.Flash().Add("success", "Opportunity was updated successfully")

	// and redirect to the opportunities index page
	return c.Render(200, r.Auto(c, opportunity))
}

// Destroy deletes a Opportunity from the DB. This function is mapped
// to the path DELETE /opportunities/{opportunity_id}
func (v OpportunitiesResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Opportunity
	opportunity := &models.Opportunity{}

	// To find the Opportunity the parameter opportunity_id is used.
	if err := tx.Find(opportunity, c.Param("opportunity_id")); err != nil {
		return c.Error(404, err)
	}

	if err := tx.Destroy(opportunity); err != nil {
		return errors.WithStack(err)
	}
	// If there are no errors set a flash message
	c.Flash().Add("success", "Opportunity was destroyed successfully")

	// Redirect to the opportunities index page
	return c.Render(200, r.Auto(c, opportunity))
}
